# 인덱싱
> 정의
> 
> 특징
> 
> 실행 이유
> 
> 종류
>
> 사용 지침

<br/>

## 정의
> 테이블에 대한 데이터 검색 속도를 높이고자 생성하며 컬럼에 적용
- <code>인덱스-데이터 레코드</code>쌍으로 구성
![image](https://github.com/bono039/TIL/assets/67899934/510f4df6-0538-47de-b6f2-94786beb9ffb)
*출처 : 데이터베이스 배움터

<br/>

## 특징
- 정렬되어 있다.
- 실제 데이터(레코드)는 정렬이 되어 있을 수도 안 되어 있을 수도 있다. ⇒ 클러스터드/넌클러스터드 인덱스
- 공간 차지


<br/>

## 실행 이유
- 테이블에 **없는 정보 검색 시 빠른 판단 가능**

<br/>

## 장단점
### 장점
- 인덱싱에 따른 오버헤드 발생
   * 인덱스를 위한 메모리 추가 소모
   * 데이터 수정,삭제 시 인덱스까지 수정해야 함

<br/>

## 종류
### B-TREE 인덱스
- Root 블록 : 분기 값 저장, 인덱스 다음 단계의 브랜치 블록을 가리키는 항목 포함
- Branch 블록 : 분기 값 저장, <code><Separator Key, DBA></code>로 구성, 아래 블록 가리킴
- Leaf 블록 : 인덱스 키 값 + ROWID 저장. <code><실제 Key값, ROWID></code>로 구성

- SELECT, INSERT, DELETE 등 작업에 효율적
- 분포도가 낮은 컬럼에 불리. OR 연산자에 대해 테이블 전체를 FULL SCAN하는 것은 험
- 테이블의 어느 데이터에 접근하더라도 동일한 성능 보장
- Double Linked List : Leaf 블록 간 양방향 통신 의미. Leaf 블록의 한 인덱스 값에서 Range 스캔을 빠르게 할 수 있게 해 줌

<br/>

### B+Tree 인덱스
- 추가,수정,삭제가 용이하지만 B-Tree보다는 느림
- 수정 시 오버헤드 더 큼

<br/>

## 사용 지침
- 튜플이 많이 들어있는 **대용량의 릴레이션**에 사용 권장
- 한 릴레이션 당 3개 이하의 인덱스 만들어야 함 (CRUD가 일어나면 인덱스를 많이 업데이트 해야 하므로)
- **삽입,수정,삭제가 자주 발생하지 않는 경우** 활용
- Integer형 속성에 인덱스를 만드는 것이 가장 좋고, 고정 길이 속성에 인덱스를 만드는 것이 좋다.
- 대량 데이터 삽입 시, 모든 인덱스를 제거하고 데이터 삽입이 끝난 후 인덱스들을 다시 생성하는 것이 좋음

<br/>

#### 🔗 참고
* [데이터베이스 인덱스 기초 개념 정리(인덱스의 정의, 특징, 사용 지침 등)](https://wkdtjsgur100.github.io/database-index/)
* [인덱스의 원리 및 종류](https://ssunws.tistory.com/45)
