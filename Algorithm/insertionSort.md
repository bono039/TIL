# 삽입 정렬

> 🔗 출처 : https://gyoogle.dev/blog/algorithm/Insertion%20Sort.html
>
>
> 1. 정의
> 2. 시간 복잡도
> 3. 공간 복잡도
> 4. 장단점
> 5. 결론

<br/>

## 정의
> <b>2번째 원소부터 시작해 그 앞의 원소들과 비교해 삽입 위치를 지정한 후, 원소를 뒤로 옮기고, 지정된 자리에 자료를 삽입</b>해 정렬하는 알고리즘

#### 예제 코드
1. 2번째 위치 idx의 값을 tmp에 저장한다.
2. tmp와 이전에 있는 원소들과 비교해 삽입한다.
3. 1번으로 돌아가 다음 위치 idx의 값을 tmp에 저장하고 반복한다.

```java
void insertionSort(int[] arr) {
  for(int idx = 1 ; idx < arr.length ; idx++){  // 1. 2번째 위치부터 탐색 시작
    int tmp = arr[idx];  // 해당 위치 idx
    int prev = idx - 1;  // 해당 위치 이전 idx

    while( (prev >= 0) && (arr[prev] > tmp) ) {    // 2. 이전 idx 값이 현재 위치 idx 값보다 크다면
      arr[prev + 1] = arr[prev];  // 서로 값 교환
      prev--;  // prev, 더 이전 위치 가리키도록
    }
    arr[prev + 1] = tmp;           // 3. 이 때의 prev, 현재 tmp보다 작은 값들 중 최댓값의 위치 idx
  }

  System.out.println(Arrays.toString(arr));
}

```

<br/>

## 시간 복잡도
- 최악 - 역으로 정렬된 경우 : <b>O(N^2)</b> = (n-1) + (n-2) + .... + 2 + 1 ⇒ n(n-1)/2
- 최선 - 모두 정렬된 경우 : <b>O(N)</b>

<br/>

## 공간 복잡도
<b>O(n)</b> - 주어진 배열 안에서 교환(swap)을 통해 정렬이 수행되므로

<br/>

## 장단점
* 장점
   * 단순한 알고리즘
   * 다른 메모리 공간 불필요 ⇒ 제자리(in-place) 정렬
   * <b>안정(stable) 정렬</b>
   * 대부분의 원소가 이미 정렬되어 있는 경우, 매우 효율적
   * 버블 정렬, 선택 정렬 比 상대적으로 빠름

* 단점
  * 평균,최악의 시간 복잡도가 O(N^2)으로 비효율적
  * 배열 길이가 길어질수록 비효율적

<br/>

## 결론
> 삽입 정렬과 유사하나, 좀 더 효율적이다!
- 공통점 : k번째 반복 이후, 첫 번째 k요소가 정렬된 순서로 온다.
- 차이점 : <code>k+1 번째 요소를 찾는 과정</code>
  * 선택 정렬 - k+1번째 요소 찾고자 <b>나머지 모든 요소 탐색</b>
  * 삽입 정렬 - k+1번째 요소를 배치하는 데 <b>필요한 만큼의 요소만큼만 탐색</b>하므로 훨씬 효율적으로 실행
